# 函数模板

## 函数模板和普通函数区别

函数模板中如果使用自动类型推导,是不可以发生隐式类型转换;但是普通函数可以

## 函数模板和普通函数调用区别

- 如果函数模板和普通函数都可以调用,优先调用普通函数

- 如果想强制调用函数模板,可以使用空模板参数列表

  ```c++
  void myPrint(int a,int b)
  {
      cout<<"普通函数调用"<<endl;
  }
  
  template<class T>
  void myPrint(T a,T b)
  {
      cout<<"函数模板调用"<<endl;
  }
  
  void test01()
  {
      int a=0,b=1;
      myPrint<>(a,b);//强制实现函数模板调用
  }
  ```

- 函数模板也可以发生重载

- 如果函数模板可以更好的匹配,则优先调用函数模板

## 模板机制及其局限性

编译过程

![](/home/zhuheqin/Pictures/编译过程.png)

### 模板实现机制

- 编译器并不是把函数模板处理成能够处理任何类型的函数
- 函数模板通过具体类型产生不同的函数
- 编译器会对函数模板进行**两次编译**,在声明的地方对模板代码本身进行编译,在调用的地方对参数后的代码进行编译

## 模板的局限性

假设有如下模板函数

```c++
template<class T>
    void func(T a,T b)
{
    ...
}
```

> 如果代码为赋值操作a=b,但是T为数组,这种假设就不成立
>
> 同样的,如果为判断语句if(a>b),但T如果是结构体,该假设也不成立;另外,如果传入的数组,数组名为地址,因此它比较的是地址,而这也不是我们所希望的操作

**总之,编写的模板函数很可能无法处理某种特定的数据类型**

但是可以通过模板函数重载来实现特定数据类型的处理