# 图解系统

## CPU如何执行程序

- Fetch：**取得指令**，通过程序计数器读取对应内存地址的指令->存储器
- Decode：**指令译码**，对指令进行解码->控制器
- Execution：**执行指令**->运算器|控制器
- Store：**数据回写**，将计算结果存回寄存器或者将寄存器的值存入内存

上述为一个指令周期

### 指令类型

指令从功能角度划分，可以分为 5 大类：

- **数据传输类型的指令**，比如 `store/load` 是寄存器与内存间数据传输的指令，`mov` 是将一个内存地址的数据移动到另一个内存地址的指令；
- **运算类型的指令**，比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据；
- **跳转类型的指令**，通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的 `if-else`、`switch-case`、函数调用等。
- **信号类型的指令**，比如发生中断的指令 `trap`；
- **闲置类型的指令**，比如指令 `nop`，执行后 CPU 会空转一个周期；

### 存储器的层次关系

![img](/home/zhuheqin/clone/blogs-notes/操作系统/存储器的层次关系图.png)

### 解决CPU缓存一致性问题

需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：

- 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为**写传播（Write Propagation）**；
- 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为**事务的串行化（Transaction Serialization）**。

要实现事务串行化，要做到 2 点：

- CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；
- 要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。

### 软中断&硬中断

硬中断和软中断是计算机系统中的两种不同类型的中断机制，用于处理异步事件或触发处理器的控制权转移。它们有不同的特性和用途：

1. **硬中断（Hardware Interrupt）**：
   - 硬中断是由计算机硬件引发的中断事件，通常由外部设备（如硬盘、键盘、网络接口卡等）触发。
   - 硬中断是异步事件，它们不依赖于处理器的执行状态，可以在任何时刻发生。
   - 当硬中断发生时，处理器会立即中断当前执行的任务，并跳转到操作系统内核中的硬中断处理程序。
   - 硬中断通常用于处理硬件设备的输入/输出操作，以及处理与硬件相关的事件。
2. **软中断（Software Interrupt）**：
   - 软中断是由软件（通常是用户程序或内核内部代码）明确触发的中断事件。
   - 软中断是同步事件，它们是由程序员控制的，通常用于请求某些操作系统服务或执行特定的系统调用。
   - 软中断的触发通常涉及到在程序中执行特殊的指令或调用特定的函数，例如在用户程序中使用系统调用来请求操作系统的服务。
   - 软中断通常用于实现用户空间和内核空间之间的通信和控制权切换，例如进行系统调用、处理异常或陷阱事件。

## 操作系统结构

### Linux内核设计理念

Linux 内核设计的理念主要有这几个点：

- *MultiTask*，多任务同时执行，并发
- *SMP*，对称多处理，每个CPU的地位是相等的，对资源的使用权限也相同
- *ELF*，可执行文件链接格式，可执行的文件存储格式
- *Monolithic Kernel*，宏内核，意味着 Linux 的内核是一个完整的可执行程序，且拥有最高的权限。宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。

## 内存管理

### 虚拟内存

#### 虚拟内存的作用

- 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
- 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

**操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。**

于是，这里就引出了两种地址的概念：

- 我们程序所使用的内存地址叫做**虚拟内存地址**（*Virtual Memory Address*）
- 实际存在硬件里面的空间地址叫**物理内存地址**（*Physical Memory Address*）

> 操作系统是如何管理虚拟地址与物理地址之间的关系？

主要有两种方式，分别是**内存分段和内存分页**。

#### 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（\*Segmentation\*）的形式把这些段分离出来。**

分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**。

段选择因子和段内偏移量：

- **段选择子**就保存在段寄存器里面。段选择子里面最重要的是**段号**，用作段表的索引。**段表**里面保存的是这个**段的基地址、段的界限和特权等级**等。
- 虚拟地址中的**段内偏移量**应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

分段产生的问题：

- 第一个就是**内存碎片**的问题。碎片分为内部碎片和外部碎片。解决外部碎片的方法是**内存交换**。内存交换导致效率低。
- 第二个就是**内存交换的效率低**的问题。

#### 内存分页

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（*Page*）。在 Linux 下，每一页的大小为 `4KB`。

页表是存储在内存里的，**内存管理单元** （*MMU*）就做将虚拟内存地址转换成物理地址的工作。

> 分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？

内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而**采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。**

但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对**内存分页机制会有内部内存碎片**的现象。

如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为**换出**（*Swap Out*）。一旦需要的时候，再加载进来，称为**换入**（*Swap In*）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，**内存交换的效率就相对比较高。**

更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是**只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。**

> 分页机制下，虚拟地址和物理地址是如何映射的？

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，**页表**包含物理页每页所在**物理内存的基地址**，这个基地址与页内偏移的组合就形成了物理内存地址。

对于一个内存地址转换，其实就是这样三个步骤：

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

**简单的页表有空间上的缺陷。**

##### 多级页表

二级分页如图

![img](/home/zhuheqin/clone/blogs-notes/操作系统/19296e249b2240c29f9c52be70f611d5.png)

对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：

- 全局页目录项 PGD（*Page Global Directory*）；
- 上层页目录项 PUD（*Page Upper Directory*）；
- 中间页目录项 PMD（*Page Middle Directory*）；
- 页表项 PTE（*Page Table Entry*）；

![img](/home/zhuheqin/clone/blogs-notes/操作系统/四级分页.png)

##### TLB（页表缓存、转址旁路缓存）

把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（*Translation Lookaside Buffer*） ，通常称为页表缓存、转址旁路缓存、快表等。

##  段页式内存管理

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为**段页式内存管理**。

段页式内存管理实现的方式：

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

这样，地址结构就由**段号、段内页号和页内位移**三部分组成。

用户空间内存  内存段：

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（[跟硬件和内核版本有关 ](http://lishiwen4.github.io/linux/linux-process-memory-location)）；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小；

## malloc

malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。

- 方式一：通过 brk() 系统调用从堆分配内存，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。
- 方式二：通过 mmap() 系统调用在文件映射区域分配内存。通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。

malloc() 源码里默认定义了一个阈值：

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

注意，不同的 glibc 版本定义的阈值也是不同的。

**malloc分配的是虚拟内存。**

malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是**会预分配更大的空间作为内存池**。

### free 释放内存，会归还给操作系统吗？

- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；
- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节，这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。

### 为什么不全部使用 mmap 来分配内存？

频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。

### 为什么不全部使用 brk 来分配？

使用brk分配内存，系统频繁的malloc和brk，堆内将会产生越来越多不可用碎片，导致内存泄漏。

## 并发和并行的区别

![并发与并行](/home/zhuheqin/clone/blogs-notes/操作系统/5-并发与并行.jpg)

## 进程

### 进程状态

- 运行状态（*Running*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，由于其他进程处于运行状态而暂时停止运行；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；
- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；
- 挂起状态：描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态
  - 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
  - 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

### 进程控制

**PCB 是进程存在的唯一标识**，PCB具体包含进程描述信息、进程控制和管理信息、资源分配清单、CPU相关信息。

PCB通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。

进程上下文切换时通常会把交换的信息保存在进程的 PCB。**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

### 进程间通信方式

- 管道
- 消息队列
- 共享内存
- 信号量
- 信号
- socket

#### 管道（不太适合进程间频繁的交换数据）

![img](/home/zhuheqin/clone/blogs-notes/操作系统/6-管道-pipe-fork.jpg)

通常的做法是：

- 父进程关闭读取的 fd[0]，只保留写入的 fd[1]；
- 子进程关闭写入的 fd[1]，只保留读取的 fd[0]；

![img](/home/zhuheqin/clone/blogs-notes/操作系统/7-管道-pipe-fork-单向通信.jpg)

## 线程

**线程是进程当中的一条执行流程**。

**线程是调度的基本单位，而进程则是资源拥有的基本单位**。

### 线程优缺点

线程的优点：

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

线程的缺点：

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃。

举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。